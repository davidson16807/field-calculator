<!doctype html>
<html>
	<head>
		<title>Field Calculator</title>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	
		<script src="http://code.jquery.com/jquery.min.js"></script>

		<script src="codemirror/codemirror.js"></script>
		<link rel="stylesheet" href="codemirror/codemirror.css">
		<script src="codemirror/clike.js"></script>

		<script src="vendor/three.js/Three.js"></script>
		<script src="vendor/three.js/Detector.js"></script>
		<script src="vendor/three.js/OrbitControls.js"></script>

		<script src="vendor/threex/THREEx.screenshot.js"></script>
		<script src="vendor/threex/THREEx.WindowResize.js"></script>
		<script src="vendor/threex.dragpancontrols.js"></script>
		<script src="vendor/threex/THREEx.Debug.js"></script>

		<link href="codemirror/monokai.css" rel="stylesheet"></link>
		<link  href="css/main.css" rel="stylesheet"/>
	</head>
<body>
	<!-- three.js container -->
	<div id="container"></div>
	<div class="top left header">
		<h1 class="title"><a href="http://davidson16807.github.io/field-calculator/">&#8711;</a></h1>
		<!-- <h2>Nabla</h2> -->
		<h3 class="subtitle">A graphing calculator for mathematical fields in &#8476;<sup>3</sup></h3>
		<div class="navigation">
			<!-- <a href="#" id="about">ABOUT</a>&nbsp; -->
			<!-- <a href="#" id="credits">CREDITS</a>&nbsp; -->
			<!-- <a href="http://github.com/davidson16807/3billionyears">CODE</a>&nbsp; -->
		</div>
	</div>
	<!-- info on screen display -->

	<div id="about-section" class="hidden details">
	</div>

	<div id="credits-section" class="hidden details">
	</div>
	</div>

	<div class="top right info" style="display: block">
		<h2 class="section-title">Options</h2>
		<table>
			<tr>
				<td>Field Type:</td>
				<td>
					<select id="field-type">
						<option value="scalar">Scalar</option>
						<option value="vector">Vector</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>Domain center:</td>
				<td>
					<input id="domain-x" type="number" value="0" step="0.1" style="width: 2.5em" />
					<sub>x</sub>
					<input id="domain-y" type="number" value="0" step="0.1" style="width: 2.5em" />
					<sub>y</sub>
					<input id="domain-z" type="number" value="0" step="0.1" style="width: 2.5em" />
					<sub>z</sub>
				</td>
			</tr>
			<tr>
				<td>Domain width:</td>
				<td>
					<input id="domain-width" type="number" value="8" style="width: 2.5em" />
				</td>
			</tr>
			<tr>
				<td>Range:</td>
				<td>
					<input id="range-min" type="number" value="0" max="1" style="width: 2.5em" />
					<sub>min</sub>
					<input id="range-max" type="number" value="1" min="0" style="width: 2.5em" />
					<sub>max</sub>
				</td>
			</tr>
		</table>
	</div> 
	<div class = "bottom right info">
		<!-- <h2 class="section-type">Code</h2> -->
		<div id="scalarFieldEditorContainer" style="opacity: 0.7">
			<textarea id="scalarFieldEditor" rows="5" cols="80" height="auto", class="fieldEditorContainer">
// Write your own code, here. 
// Code must be written in glsl.
// Hit ctrl+s to update the view.
float f(vec3 x){
	return cos(x.x) * cos(x.y) * cos(x.z);
}
			</textarea>
		</div>

		<div id="vectorFieldEditorContainer" style="opacity: 0.7" class="fieldEditorContainer">
			<textarea id="vectorFieldEditor" rows="5" cols="80" height="auto">
// Write your own code, here. 
// Code must be written in glsl.
// Hit ctrl+s to update the view.
const float dx = 0.001;
const vec3 i = vec3(1,0,0);
const vec3 j = vec3(0,1,0);
const vec3 k = vec3(0,0,1);
float g(vec3 x){
  return cos(x.x) * cos(x.y) * cos(x.z);
}
vec3 f(vec3 x){
  return vec3(
	g(x+dx*i)-g(x),
	g(x+dx*j)-g(x),
	g(x+dx*k)-g(x)) / dx;
}
			</textarea>
		</div>
	</div>
    <script type="x-shader/x-vertex" id="vectorVertexShader">
		varying vec3 vPosition;
		uniform int resolution;
		uniform vec4 domain_center;
		uniform float domain_width;
		uniform vec2 range;
		attribute float is_vector; // positive=true, negative=false

		//USER_INPUT_GOES_HERE
		
		void main() {
			vPosition = position * domain_width/2. + domain_center.xyz;
			vec3 vector = f(vPosition);
			gl_Position = 
				projectionMatrix * 
				modelViewMatrix * 
				vec4( is_vector > 0.? 
					position + vector / float(resolution) : 
					position,      1.0 );
		}
    </script>
    <script type="x-shader/x-fragment" id="vectorFragmentShader">
        const float PI = 3.1415926;

        varying vec3 vPosition;
		uniform int resolution;
		uniform vec2 range;

        //converts float from 0-1 to a heat map visualtion
        //credit goes to Gaëtan Renaudeau: http://greweb.me/glsl.js/examples/heatmap/
        vec3 heat (float v) {
        	float value = 1.-v;
        	return (0.5+0.5*smoothstep(0.0, 0.1, value))*vec3(
        		smoothstep(0.5, 0.3, value),
        		value < 0.3 ? smoothstep(0.0, 0.3, value) : smoothstep(1.0, 0.6, value),
        		smoothstep(0.4, 0.6, value)
        	);
        }

        //USER_INPUT_GOES_HERE

        void main() {
        	vec3 vector = f(vPosition);
        	float magnitude = sqrt(dot(vector,vector));
        	float display_value = clamp(magnitude, range.x, range.y)/(range.y-range.x);
            gl_FragColor = vec4(heat(display_value), 1./display_value);
        }
    </script>
    <script type="x-shader/x-vertex" id="scalarVertexShader">
		varying vec3 vPosition;
		uniform int resolution;
		uniform vec4 domain_center;
		uniform float domain_width;
		uniform vec2 range;

		//USER_INPUT_GOES_HERE

		void main() {
			vPosition = position * domain_width/2. + domain_center.xyz;
			float scalar = f(vPosition);
        	float display_value = clamp(scalar, range.x, range.y)/(range.y-range.x);
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_PointSize = 10.*display_value; 
		}
    </script>
    <script type="x-shader/x-fragment" id="scalarFragmentShader">
        const float PI = 3.1415926;

        varying vec3 vPosition;
		uniform int resolution;
		uniform vec2 range;

        //converts float from 0-1 to a heat map visualtion
        //credit goes to Gaëtan Renaudeau: http://greweb.me/glsl.js/examples/heatmap/
        vec3 heat (float v) {
        	float value = 1.-v;
        	return (0.5+0.5*smoothstep(0.0, 0.1, value))*vec3(
        		smoothstep(0.5, 0.3, value),
        		value < 0.3 ? smoothstep(0.0, 0.3, value) : smoothstep(1.0, 0.6, value),
        		smoothstep(0.4, 0.6, value)
        	);
        }

        //USER_INPUT_GOES_HERE

        void main() {
        	float scalar = f(vPosition);
        	float display_value = clamp(scalar, range.x, range.y)/(range.y-range.x);
            gl_FragColor = vec4(heat(display_value), 1./display_value);
        }
    </script> 

	<script type="text/javascript">
		var vectorFieldEditor = CodeMirror.fromTextArea($('#vectorFieldEditor')[0], {
			extraKeys: {
				'Ctrl-S': function(){
					vectorShader.vertexShader = $('#vectorVertexShader').text().replace("//USER_INPUT_GOES_HERE", vectorFieldEditor.getValue());
					vectorShader.fragmentShader = $('#vectorFragmentShader').text().replace("//USER_INPUT_GOES_HERE", vectorFieldEditor.getValue());
					vectorShader.needsUpdate = true;
				}
			},
			mode: "x-shader/x-vertex",
			lineNumbers: true,
		});
		vectorFieldEditor.setSize(400,150);
		vectorFieldEditor.setOption("theme", "monokai");

		var scalarFieldEditor = CodeMirror.fromTextArea($('#scalarFieldEditor')[0], {
			extraKeys: {
				'Ctrl-S': function(){
					scalarShader.vertexShader = $('#scalarVertexShader').text().replace("//USER_INPUT_GOES_HERE", scalarFieldEditor.getValue());
					scalarShader.fragmentShader = $('#scalarFragmentShader').text().replace("//USER_INPUT_GOES_HERE", scalarFieldEditor.getValue());
					scalarShader.needsUpdate = true;
				}
			},
			mode: "x-shader/x-vertex",
			lineNumbers: true,
		});
		scalarFieldEditor.setSize(400,150);
		scalarFieldEditor.setOption("theme", 'monokai');

		$('#vectorFieldEditorContainer').hide();
		var scene, renderer, composer, clock;
		var camera, cameraControl;
	    var image = document.createElement( 'img' );

		var resolution = 5;

		var scalarGeometry	= new THREE.Geometry();
		var vectorGeometry	= new THREE.Geometry();
	    var scalarShader = new THREE.ShaderMaterial({
	        vertexShader: $('#scalarVertexShader').text().replace("//USER_INPUT_GOES_HERE", scalarFieldEditor.getValue()),
	        fragmentShader: $('#scalarFragmentShader').text().replace("//USER_INPUT_GOES_HERE", scalarFieldEditor.getValue()),
	        attributes: {
	        },
	        uniforms: {
	        	resolution: { type: 'i', value: resolution },
	        	center: { type: 'v4', value: new THREE.Vector4( 0,0,0,0 ) },
	        	domain_width: { type: 'f', value: 8 },
	        	domain_center: { type: 'v4', value: new THREE.Vector4(0,0,0,0) },
	        	range: { type: 'v2', value: new THREE.Vector2(0,1) }
	        }
	    });
	    var vectorShader = new THREE.ShaderMaterial({
	        vertexShader: $('#vectorVertexShader').text().replace("//USER_INPUT_GOES_HERE", vectorFieldEditor.getValue()),
	        fragmentShader: $('#vectorFragmentShader').text().replace("//USER_INPUT_GOES_HERE", vectorFieldEditor.getValue()),
	        attributes: {
	        	is_vector: { type: 'f', value: [] }
	        },
	        uniforms: {
	        	resolution: { type: 'i', value: resolution },
	        	center: { type: 'v4', value: new THREE.Vector4( 0,0,0,0 ) },
	        	domain_width: { type: 'f', value: 8 },
	        	domain_center: { type: 'v4', value: new THREE.Vector4(0,0,0,0) },
	        	range: { type: 'v2', value: new THREE.Vector2(0,1) }
	        }
	    });

		var resolution = 25;
		for (var i = 0; i <= resolution; i++) {
			for (var j = 0; j <= resolution; j++) {
				for (var k = 0; k <= resolution; k++) {
					for(var l = 0; l<2; l++){ //l is used to represent vectors when mesh == THREE.Line
						scalarGeometry.vertices.push(new THREE.Vector3((2*i/resolution-1),(2*j/resolution-1),(2*k/resolution-1)));
						vectorGeometry.vertices.push(new THREE.Vector3((2*i/resolution-1),(2*j/resolution-1),(2*k/resolution-1)));
						vectorShader.attributes.is_vector.value.push(2*l-1); 
						//.value[i*resolution*resolution + j*resolution + k*2 +l] = 
					} 
				}
			}
		};	
		vectorShader.attributes.is_vector.needsUpdate = true;

		var scalarField = new THREE.ParticleSystem(scalarGeometry, scalarShader);
		var vectorField	= new THREE.Line( vectorGeometry, vectorShader, THREE.LinePieces);
		// vectorField.visible = false;
		var field = scalarField;
		var MegaYearsPerSecond = 20;
		var Paused = true;
		var Time = 0;

		if( !init() ){
			animate();
		}
		
		// init the scene
		function init(){
			clock = new THREE.Clock();

			if( Detector.webgl ){
				renderer = new THREE.WebGLRenderer({
					antialias		: true,	// to get smoother output
					preserveDrawingBuffer	: true	// to allow screenshot
				});
				renderer.setClearColor( 0x000000 );
			}else{
				Detector.addGetWebGLMessage();
				return true;
			}
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.getElementById('container').appendChild(renderer.domElement);

			// create a scene
			scene = new THREE.Scene();

			// put a camera in the scene
			camera	= new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set(0, 0, 5);
			scene.add(camera);

			// create a camera contol
			cameraControls	= new THREE.OrbitControls( camera, $("#container").get(0) );

			// transparently support window resize
			THREEx.WindowResize.bind(renderer, camera);
			// allow 'p' to make screenshot
			// THREEx.Screenshot.bindKey(renderer);

			// here you add your objects
			// - you will most likely replace this part by your own
			var light	= new THREE.AmbientLight(  0xffffff );
			scene.add( light );
			scene.add( scalarField );
			// scene.add( vectorField );
		}

		// animation loop
		function animate() {

			// loop on request animation loop
			// - it has to be at the begining of the function
			// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
			requestAnimationFrame( animate );

			// variable which is increase by Math.PI every seconds - usefull for animation
			var PIseconds	= Date.now() * Math.PI;

			// update camera controls
			cameraControls.update();

			// actually render the scene
			renderer.render( scene, camera );

			if(Paused){
				return;
			}

			var seconds = clock.getDelta();
			if (seconds > 1){
				seconds = 1;
			}
			
			var timestep = seconds * MegaYearsPerSecond;
			Time += timestep;
			loadTime(Time);
		}

		$('#field-type').change(function(event) {
			scene.remove(field);
			$('#scalarFieldEditorContainer').hide();
			$('#vectorFieldEditorContainer').hide();

			var field_type = $(this).val();
			if (field_type == "scalar") {
				field = scalarField;
				$('#scalarFieldEditorContainer').show();
			} else {
				field = vectorField;
				$('#vectorFieldEditorContainer').show();
			}

			scene.add(field);
		});
		$('#domain-x').change(function(event) {
			vectorShader.uniforms.domain_center.value.x = $('#domain-x').val();
			vectorShader.uniforms.domain_center.needsUpdate = true;
			scalarShader.uniforms.domain_center.value.x = $('#domain-x').val();
			scalarShader.uniforms.domain_center.needsUpdate = true;
		});
		$('#domain-y').change(function(event) {
			vectorShader.uniforms.domain_center.value.y = $('#domain-y').val();
			vectorShader.uniforms.domain_center.needsUpdate = true;
			scalarShader.uniforms.domain_center.value.y = $('#domain-y').val();
			scalarShader.uniforms.domain_center.needsUpdate = true;
		});
		$('#domain-z').change(function(event) {
			vectorShader.uniforms.domain_center.value.z = $('#domain-z').val();
			vectorShader.uniforms.domain_center.needsUpdate = true;
			scalarShader.uniforms.domain_center.value.z = $('#domain-z').val();
			scalarShader.uniforms.domain_center.needsUpdate = true;
		});
		$('#domain-width').change(function(e) {
			vectorShader.uniforms.domain_width.value = $('#domain-width').val();
			vectorShader.uniforms.domain_width.needsUpdate = true;
			scalarShader.uniforms.domain_width.value = $('#domain-width').val();
			scalarShader.uniforms.domain_width.needsUpdate = true;
		});
		$('#range-max').change(function(event) {
			$('#range-min').attr('max', $('#range-max').val());
			vectorShader.uniforms.range.value.y = $('#range-max').val();
			vectorShader.uniforms.range.needsUpdate = true;
			scalarShader.uniforms.range.value.y = $('#range-max').val();
			scalarShader.uniforms.range.needsUpdate = true;
		});
		$('#range-min').change(function(event) {
			$('#range-max').attr('min', $('#range-min').val());
			vectorShader.uniforms.range.value.x = $('#range-min').val();
			vectorShader.uniforms.range.needsUpdate = true;
			scalarShader.uniforms.range.value.x = $('#range-min').val();
			scalarShader.uniforms.range.needsUpdate = true;
		});
	</script>
</body>
</html>